<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Animated Presentation</title>
  <style>
    :root {
      --aspect-ratio: 1.7777778;
      --stage-gap: 14px;
      --text: #f0f1f3;
      --panel: rgba(17, 20, 24, 0.72);
      --panel-border: rgba(255, 255, 255, 0.16);
      --move-distance: 100px;
      --stagger: 220ms;
      --anim-duration: 1040ms;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      min-width: 100%;
      min-height: 100%;
      overflow: hidden;
      color: var(--text);
      font-family: "Segoe UI", "Trebuchet MS", sans-serif;
      background-color: #06080c;
      background:
        radial-gradient(90vw 90vh at 15% 15%, #23262b 0%, rgba(35, 38, 43, 0) 65%),
        radial-gradient(80vw 80vh at 85% 85%, #2a2a2a 0%, rgba(42, 42, 42, 0) 60%),
        #06080c;
    }

    body {
      min-width: 100vw;
      min-height: 100vh;
      min-width: 100dvw;
      min-height: 100dvh;
      overscroll-behavior: none;
    }

    #app {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      width: 100dvw;
      height: 100dvh;
      display: grid;
      place-items: center;
      padding: 0;
    }

    #stage-wrap {
      position: relative;
      width: min(
        calc(100vw - (var(--stage-gap) * 2)),
        calc((100vh - (var(--stage-gap) * 2)) * var(--aspect-ratio))
      );
      height: min(
        calc(100vh - (var(--stage-gap) * 2)),
        calc((100vw - (var(--stage-gap) * 2)) / var(--aspect-ratio))
      );
      width: min(
        calc(100dvw - (var(--stage-gap) * 2)),
        calc((100dvh - (var(--stage-gap) * 2)) * var(--aspect-ratio))
      );
      height: min(
        calc(100dvh - (var(--stage-gap) * 2)),
        calc((100dvw - (var(--stage-gap) * 2)) / var(--aspect-ratio))
      );
      border-radius: 14px;
      overflow: hidden;
      background: #000;
      box-shadow:
        0 30px 60px rgba(0, 0, 0, 0.55),
        inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #stage {
      position: absolute;
      inset: 0;
      isolation: isolate;
    }

    .layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      transform: translate3d(0, 0, 0);
      will-change: opacity, transform;
      pointer-events: none;
      user-select: none;
    }

    #pager {
      position: absolute;
      left: 50%;
      bottom: 12px;
      bottom: max(12px, env(safe-area-inset-bottom));
      transform: translateX(-50%);
      z-index: 9000;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      background: rgba(17, 20, 24, 0.62);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(8px);
      cursor: default;
      opacity: 0;
      pointer-events: none;
      transition: opacity 140ms ease;
    }

    #pager.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .pager-dot {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1.5px solid rgba(255, 255, 255, 0.9);
      background: transparent;
      padding: 0;
      cursor: default;
    }

    .pager-dot.active {
      background: rgba(255, 255, 255, 0.95);
    }

    .pager-dot:focus-visible {
      outline: 2px solid rgba(255, 255, 255, 0.9);
      outline-offset: 2px;
    }

    #swipe-hint {
      position: absolute;
      inset: 0;
      z-index: 9500;
      pointer-events: none;
      opacity: 0;
      transition: opacity 120ms ease;
    }

    #swipe-hint.visible {
      opacity: 1;
    }

    #swipe-hint-dot {
      position: absolute;
      left: 50%;
      top: 54%;
      width: 40px;
      height: 40px;
      margin-left: -20px;
      margin-top: -20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.24);
      border: 1.5px solid rgba(255, 255, 255, 0.72);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: translateX(88px) scale(0.95);
    }

    #swipe-hint.visible #swipe-hint-dot {
      animation: swipe-hint-dot 2200ms cubic-bezier(0.2, 0.8, 0.2, 1) 1 both;
    }

    @keyframes swipe-hint-dot {
      0% {
        opacity: 0;
        transform: translateX(88px) scale(0.95);
      }
      22% {
        opacity: 0.76;
        transform: translateX(88px) scale(1);
      }
      70% {
        opacity: 0.72;
        transform: translateX(-88px) scale(1);
      }
      90% {
        opacity: 0.56;
        transform: translateX(-88px) scale(0.98);
      }
      100% {
        opacity: 0;
        transform: translateX(-88px) scale(0.95);
      }
    }

    #corner-logo-link {
      position: fixed;
      right: 14px;
      right: max(14px, env(safe-area-inset-right));
      bottom: 14px;
      bottom: max(14px, env(safe-area-inset-bottom));
      z-index: 12000;
      opacity: 0;
      pointer-events: none;
      transform: translateY(6px);
      transition: opacity 160ms ease, transform 160ms ease;
    }

    #corner-logo-link.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    #corner-logo {
      display: block;
      width: auto;
      height: 40px;
      user-select: none;
      -webkit-user-drag: none;
    }

    #loading,
    #error {
      position: absolute;
      inset: 0;
      z-index: 10000;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 24px;
      font-size: clamp(16px, 2vw, 24px);
      background: linear-gradient(120deg, rgba(7, 10, 14, 0.95), rgba(12, 17, 20, 0.85));
    }

    #loading.hidden,
    #error.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <main id="app">
    <section id="stage-wrap" aria-label="presentation stage">
      <div id="loading">Загрузка изображений...</div>
      <div id="error" class="hidden"></div>
      <div id="stage"></div>
      <div id="pager" aria-label="slide pages"></div>
      <div id="swipe-hint" aria-hidden="true"><div id="swipe-hint-dot"></div></div>
    </section>
  </main>
  <a
    id="corner-logo-link"
    href="https://kaurov.net/ru.html"
    aria-label="Открыть сайт KAUROV"
  >
    <img id="corner-logo" src="./img/kaurov-logo-black.svg" alt="KAUROV" />
  </a>

  <script>
    const IMAGE_EXT_RE = /\.(png|jpe?g|webp|gif|avif|svg)$/i;
    const META_RE = /slide-(\d+)-(\d+)-IN-([a-z]+)-OUT-([a-z]+)/i;
    const SIZE_RE = /-(\d+)x(\d+)-slide-/i;

    const MOVE_DISTANCE = 100;

    // Fixed timing values. Edit these four numbers if you need to retune animations.
    const ANIMATION_TIMING = Object.freeze({
      IN_DURATION_MS: 2000,
      IN_START_DELAY_MS: 200,
      OUT_DURATION_MS: 500,
      OUT_START_DELAY_MS: 50
    });
    const SWIPE_SETTINGS = Object.freeze({
      MIN_DISTANCE_PX: 42,
      MAX_OFF_AXIS_PX: 90,
      MAX_DURATION_MS: 700,
      SUPPRESS_CLICK_MS: 420
    });
    const SWIPE_HINT_SETTINGS = Object.freeze({
      INITIAL_DELAY_MS: 1200,
      DURATION_MS: 2200
    });
    const LOGO_TRIGGER_ZONE = Object.freeze({
      WIDTH_PX: 115,
      HEIGHT_PX: 85
    });
    const HAS_TOUCH_INPUT = window.matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;

    const stageWrap = document.getElementById("stage-wrap");
    const stage = document.getElementById("stage");
    const pagerNode = document.getElementById("pager");
    const swipeHintNode = document.getElementById("swipe-hint");
    const loadingNode = document.getElementById("loading");
    const errorNode = document.getElementById("error");
    const cornerLogoLink = document.getElementById("corner-logo-link");

    let slides = [];
    let currentSlideIndex = 0;
    let requestedSlideIndex = 0;
    let activeLayers = [];
    let isTransitioning = false;
    let isCornerLogoHovered = false;
    let swipeHintTimeoutId = null;
    let touchSwipeStart = null;
    let suppressClickUntilTs = 0;

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function setAspectRatio(width, height) {
      if (!width || !height) return;
      stageWrap.style.setProperty("--aspect-ratio", String(width / height));
    }

    function normalizeDiscoveredPath(path) {
      const raw = decodeURIComponent(String(path || "")).replace(/\\/g, "/").replace(/^\.\//, "");
      if (raw.startsWith("http://") || raw.startsWith("https://")) {
        try {
          const url = new URL(raw);
          return url.pathname.replace(/^\/+/, "");
        } catch {
          return raw;
        }
      }

      let clean = raw.replace(/^\/+/, "");
      const nestedImgMatch = clean.match(/(?:^|\/)(img\/.+)$/i);
      if (nestedImgMatch) {
        clean = nestedImgMatch[1];
      }

      if (clean.startsWith("img/")) {
        return clean;
      }
      return `img/${clean.replace(/^\/+/, "")}`;
    }

    function normalizeDirection(direction, fallback) {
      const value = String(direction || fallback).toLowerCase();
      if (value === "top") return "up";
      if (value === "bottom") return "down";
      return value;
    }

    function moveInVector(direction) {
      switch (normalizeDirection(direction, "left")) {
        case "left":
          return [MOVE_DISTANCE, 0];
        case "right":
          return [-MOVE_DISTANCE, 0];
        case "up":
          return [0, MOVE_DISTANCE];
        case "down":
          return [0, -MOVE_DISTANCE];
        case "static":
          return [0, 0];
        default:
          return [MOVE_DISTANCE, 0];
      }
    }

    function moveOutVector(direction) {
      switch (normalizeDirection(direction, "right")) {
        case "left":
          return [-MOVE_DISTANCE, 0];
        case "right":
          return [MOVE_DISTANCE, 0];
        case "up":
          return [0, -MOVE_DISTANCE];
        case "down":
          return [0, MOVE_DISTANCE];
        case "static":
          return [0, 0];
        default:
          return [MOVE_DISTANCE, 0];
      }
    }

    function parseMeta(path) {
      const full = normalizeDiscoveredPath(path);
      const fileName = full.split("/").pop() || "";
      const baseName = fileName.replace(/\.[^.]+$/, "");
      const match = baseName.match(META_RE);
      if (!match) return null;

      const size = baseName.match(SIZE_RE);
      return {
        src: `./${full}`,
        slide: Number(match[1]),
        layer: Number(match[2]),
        inDir: String(match[3]).toLowerCase(),
        outDir: String(match[4]).toLowerCase(),
        width: size ? Number(size[1]) : null,
        height: size ? Number(size[2]) : null,
        fileName
      };
    }

    function buildSlides(paths) {
      const parsed = paths.map(parseMeta).filter(Boolean);
      if (!parsed.length) {
        throw new Error("Не удалось найти изображения формата *-slide-XX-YY-IN-*-OUT-* в папке img.");
      }

      const withSize = parsed.find((item) => item.width && item.height);
      if (withSize) {
        setAspectRatio(withSize.width, withSize.height);
      }

      const grouped = new Map();
      for (const layer of parsed) {
        if (!grouped.has(layer.slide)) {
          grouped.set(layer.slide, []);
        }
        grouped.get(layer.slide).push(layer);
      }

      return [...grouped.entries()]
        .sort((a, b) => a[0] - b[0])
        .map(([slideNumber, layers]) => ({
          slideNumber,
          layers: layers.sort((a, b) => a.layer - b.layer)
        }));
    }

    async function tryLoadJsonList(path) {
      try {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) return [];
        const data = await res.json();
        if (!Array.isArray(data)) return [];
        return data.map(String).filter((name) => IMAGE_EXT_RE.test(name));
      } catch {
        return [];
      }
    }

    async function discoverFromDirectoryListing() {
      try {
        const res = await fetch("./img/", { cache: "no-store" });
        if (!res.ok) return [];
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");
        const links = [...doc.querySelectorAll("a")]
          .map((a) => a.getAttribute("href") || "")
          .map((href) => href.split("?")[0].split("#")[0])
          .filter((href) => href && !href.endsWith("/") && href !== "../")
          .map((href) => decodeURIComponent(href));

        const images = links.filter((href) => IMAGE_EXT_RE.test(href));
        return [...new Set(images)].map((name) => normalizeDiscoveredPath(name));
      } catch {
        return [];
      }
    }

    async function discoverImageFiles() {
      const jsonCandidates = [
        "./img/manifest.json",
        "./img/images.json",
        "./img/list.json"
      ];

      for (const candidate of jsonCandidates) {
        const list = await tryLoadJsonList(candidate);
        if (list.length) {
          return list.map(normalizeDiscoveredPath);
        }
      }

      const fromListing = await discoverFromDirectoryListing();
      if (fromListing.length) {
        return fromListing;
      }

      throw new Error(
        "Не удалось получить список изображений. Добавьте ./img/manifest.json (массив имён файлов) или включите листинг папки ./img/."
      );
    }

    async function preloadImages(paths) {
      const unique = [...new Set(paths.map(normalizeDiscoveredPath))];
      let loaded = 0;

      const jobs = unique.map((path) => {
        const src = `./${path}`;
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            loaded += 1;
            loadingNode.textContent = `Загрузка изображений... ${loaded}/${unique.length}`;
            resolve();
          };
          img.onerror = () => reject(new Error(`Ошибка загрузки: ${src}`));
          img.src = src;
        });
      });

      await Promise.all(jobs);
    }

    function createLayer(meta) {
      const img = document.createElement("img");
      img.className = "layer";
      img.src = meta.src;
      img.alt = meta.fileName;
      img.style.zIndex = String(100000 - meta.layer);
      return { meta, el: img };
    }

    function cancelElementAnimations(el) {
      el.getAnimations().forEach((anim) => anim.cancel());
    }

    function hideSwipeHint() {
      if (swipeHintTimeoutId !== null) {
        clearTimeout(swipeHintTimeoutId);
        swipeHintTimeoutId = null;
      }
      swipeHintNode.classList.remove("visible");
    }

    function showSwipeHintOnce() {
      if (!HAS_TOUCH_INPUT) return;
      swipeHintNode.classList.remove("visible");
      // Restart animation if the class was just removed.
      void swipeHintNode.offsetWidth;
      swipeHintNode.classList.add("visible");
      if (swipeHintTimeoutId !== null) {
        clearTimeout(swipeHintTimeoutId);
      }
      swipeHintTimeoutId = setTimeout(() => {
        swipeHintNode.classList.remove("visible");
        swipeHintTimeoutId = null;
      }, SWIPE_HINT_SETTINGS.DURATION_MS + 100);
    }

    function updatePagerActive() {
      const dots = pagerNode.querySelectorAll(".pager-dot");
      dots.forEach((dot, index) => {
        const isActive = index === requestedSlideIndex;
        dot.classList.toggle("active", isActive);
        dot.setAttribute("aria-current", isActive ? "true" : "false");
      });
    }

    function renderPager() {
      pagerNode.textContent = "";
      const fragment = document.createDocumentFragment();
      slides.forEach((slide, index) => {
        const dot = document.createElement("button");
        dot.type = "button";
        dot.className = "pager-dot";
        dot.dataset.index = String(index);
        dot.title = `Слайд ${slide.slideNumber}`;
        dot.setAttribute("aria-label", `Перейти на слайд ${slide.slideNumber}`);
        fragment.appendChild(dot);
      });
      pagerNode.appendChild(fragment);
      updatePagerActive();
    }

    async function animateIn(entry) {
      cancelElementAnimations(entry.el);
      const [x, y] = moveInVector(entry.meta.inDir);
      const anim = entry.el.animate(
        [
          { opacity: 0, transform: `translate3d(${x}px, ${y}px, 0)` },
          { opacity: 1, transform: "translate3d(0, 0, 0)" }
        ],
        {
          duration: ANIMATION_TIMING.IN_DURATION_MS,
          easing: "cubic-bezier(0.22, 1, 0.36, 1)",
          fill: "forwards"
        }
      );
      await anim.finished.catch(() => {});
    }

    async function animateOut(entry) {
      const computed = getComputedStyle(entry.el);
      const fromOpacity = computed.opacity || "1";
      const fromTransform = computed.transform === "none"
        ? "translate3d(0, 0, 0)"
        : computed.transform;
      cancelElementAnimations(entry.el);
      const [x, y] = moveOutVector(entry.meta.outDir);
      const anim = entry.el.animate(
        [
          { opacity: fromOpacity, transform: fromTransform },
          { opacity: 0, transform: `translate3d(${x}px, ${y}px, 0)` }
        ],
        {
          duration: ANIMATION_TIMING.OUT_DURATION_MS,
          easing: "cubic-bezier(0.55, 0.08, 0.68, 0.53)",
          fill: "forwards"
        }
      );
      await anim.finished.catch(() => {});
      entry.el.remove();
    }

    async function showSlide(slide) {
      const orderFromBottom = [...slide.layers].sort((a, b) => b.layer - a.layer);
      const entries = orderFromBottom.map(createLayer);
      const staggerMs = ANIMATION_TIMING.IN_START_DELAY_MS;

      for (const entry of entries) {
        stage.appendChild(entry.el);
      }

      // Mark slide layers as active before animations finish, so hide logic
      // always has the full current set.
      activeLayers = entries;

      return Promise.all(
        entries.map((entry, index) =>
          sleep(index * staggerMs).then(() => animateIn(entry))
        )
      );
    }

    async function hideActiveSlide() {
      const orderFromBottom = [...activeLayers].sort((a, b) => b.meta.layer - a.meta.layer);
      const staggerMs = ANIMATION_TIMING.OUT_START_DELAY_MS;
      await Promise.all(
        orderFromBottom.map((entry, index) =>
          sleep(index * staggerMs).then(() => animateOut(entry))
        )
      );
      activeLayers = [];
    }

    async function goToSlide(targetIndex) {
      if (!slides.length) return;

      const clampedTarget = Math.max(0, Math.min(targetIndex, slides.length - 1));
      requestedSlideIndex = clampedTarget;
      hideSwipeHint();
      updatePagerActive();

      if (isTransitioning) return;

      isTransitioning = true;
      try {
        while (requestedSlideIndex !== currentSlideIndex) {
          await hideActiveSlide();
          currentSlideIndex = requestedSlideIndex;
          void showSlide(slides[currentSlideIndex]);
        }
      } finally {
        isTransitioning = false;
      }
    }

    async function goNextSlide() {
      await goToSlide(requestedSlideIndex + 1);
    }

    async function goPrevSlide() {
      await goToSlide(requestedSlideIndex - 1);
    }

    function showError(message) {
      loadingNode.classList.add("hidden");
      errorNode.textContent = message;
      errorNode.classList.remove("hidden");
    }

    async function start() {
      isTransitioning = true;
      try {
        const files = await discoverImageFiles();
        await preloadImages(files);
        slides = buildSlides(files);
        if (!slides.length) {
          throw new Error("Слайды не найдены.");
        }

        currentSlideIndex = 0;
        requestedSlideIndex = 0;
        renderPager();
        loadingNode.classList.add("hidden");
        syncLogoOffsetWithStage();
        void showSlide(slides[currentSlideIndex]);
        setTimeout(() => {
          if (currentSlideIndex === 0 && requestedSlideIndex === 0 && !isTransitioning) {
            showSwipeHintOnce();
          }
        }, SWIPE_HINT_SETTINGS.INITIAL_DELAY_MS);
      } catch (error) {
        const message = error instanceof Error ? error.message : "Неизвестная ошибка";
        showError(
          `${message}\n\nЗапускайте страницу через локальный сервер (например: python -m http.server), если браузер блокирует чтение папки img.`
        );
      } finally {
        isTransitioning = false;
      }
    }

    document.addEventListener("keydown", (event) => {
      if (event.code === "Space" || event.code === "ArrowRight") {
        event.preventDefault();
        void goNextSlide();
        return;
      }
      if (event.code === "ArrowLeft") {
        event.preventDefault();
        void goPrevSlide();
      }
    });

    stageWrap.addEventListener("click", (event) => {
      if (Date.now() < suppressClickUntilTs) {
        return;
      }
      if (event.target instanceof Element && event.target.closest("#pager")) {
        return;
      }
      const rect = stageWrap.getBoundingClientRect();
      const relativeX = event.clientX - rect.left;
      if (relativeX < rect.width / 2) {
        void goPrevSlide();
      } else {
        void goNextSlide();
      }
    });

    pagerNode.addEventListener("click", (event) => {
      const target = event.target instanceof Element ? event.target.closest(".pager-dot") : null;
      if (!(target instanceof HTMLElement)) return;
      event.stopPropagation();
      const index = Number(target.dataset.index);
      if (!Number.isFinite(index)) return;
      void goToSlide(index);
    });

    function onTouchStart(event) {
      if (event.target instanceof Element && event.target.closest("#pager")) {
        touchSwipeStart = null;
        return;
      }
      if (event.touches.length !== 1) {
        touchSwipeStart = null;
        return;
      }
      const touch = event.touches[0];
      touchSwipeStart = {
        x: touch.clientX,
        y: touch.clientY,
        time: performance.now()
      };
    }

    function onTouchEnd(event) {
      if (!touchSwipeStart) return;
      if (event.changedTouches.length !== 1) {
        touchSwipeStart = null;
        return;
      }

      const touch = event.changedTouches[0];
      const dx = touch.clientX - touchSwipeStart.x;
      const dy = touch.clientY - touchSwipeStart.y;
      const dt = performance.now() - touchSwipeStart.time;
      touchSwipeStart = null;

      if (dt > SWIPE_SETTINGS.MAX_DURATION_MS) return;
      if (Math.abs(dx) < SWIPE_SETTINGS.MIN_DISTANCE_PX) return;
      if (Math.abs(dy) > SWIPE_SETTINGS.MAX_OFF_AXIS_PX) return;
      if (Math.abs(dx) <= Math.abs(dy)) return;

      suppressClickUntilTs = Date.now() + SWIPE_SETTINGS.SUPPRESS_CLICK_MS;
      if (dx < 0) {
        void goNextSlide();
      } else {
        void goPrevSlide();
      }
    }

    function onTouchCancel() {
      touchSwipeStart = null;
    }

    if (HAS_TOUCH_INPUT) {
      stageWrap.addEventListener("touchstart", onTouchStart, { passive: true });
      stageWrap.addEventListener("touchend", onTouchEnd, { passive: true });
      stageWrap.addEventListener("touchcancel", onTouchCancel, { passive: true });
    }

    const LEFT_CURSOR = (() => {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path d="M19 6L9 14L19 22" fill="none" stroke="white" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19 6L9 14L19 22" fill="none" stroke="black" stroke-opacity="0.45" stroke-width="5.8" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      return `url("data:image/svg+xml,${encodeURIComponent(svg)}") 14 14, w-resize`;
    })();

    const RIGHT_CURSOR = (() => {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path d="M9 6L19 14L9 22" fill="none" stroke="white" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 6L19 14L9 22" fill="none" stroke="black" stroke-opacity="0.45" stroke-width="5.8" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      return `url("data:image/svg+xml,${encodeURIComponent(svg)}") 14 14, e-resize`;
    })();

    function updateDirectionalCursor(clientX, target) {
      if (target instanceof Element && target.closest("#pager")) {
        stageWrap.style.cursor = "default";
        return;
      }
      const rect = stageWrap.getBoundingClientRect();
      const relativeX = clientX - rect.left;
      stageWrap.style.cursor = relativeX < rect.width / 2 ? LEFT_CURSOR : RIGHT_CURSOR;
    }

    function updatePagerVisibility(clientY) {
      const rect = stageWrap.getBoundingClientRect();
      const relativeY = clientY - rect.top;
      const inBottomThird = relativeY >= rect.height * (2 / 3);
      pagerNode.classList.toggle("visible", inBottomThird);
    }

    function syncLogoOffsetWithStage() {
      const rect = stageWrap.getBoundingClientRect();
      const rightOffset = Math.max(0, window.innerWidth - rect.right);
      const bottomOffset = Math.max(0, window.innerHeight - rect.bottom);
      const minOffset = Math.min(rightOffset, bottomOffset);
      cornerLogoLink.style.right = `${minOffset}px`;
      cornerLogoLink.style.bottom = `${minOffset}px`;
    }

    function updateCornerLogoVisibility(clientX, clientY) {
      const inCorner =
        clientX >= window.innerWidth - LOGO_TRIGGER_ZONE.WIDTH_PX &&
        clientY >= window.innerHeight - LOGO_TRIGGER_ZONE.HEIGHT_PX;
      cornerLogoLink.classList.toggle("visible", inCorner || isCornerLogoHovered);
    }

    stageWrap.addEventListener("mouseenter", (event) => {
      updateDirectionalCursor(event.clientX, event.target);
      updatePagerVisibility(event.clientY);
    });

    stageWrap.addEventListener("mousemove", (event) => {
      updateDirectionalCursor(event.clientX, event.target);
      updatePagerVisibility(event.clientY);
    });

    stageWrap.addEventListener("mouseleave", () => {
      stageWrap.style.cursor = "default";
      pagerNode.classList.remove("visible");
    });

    window.addEventListener("mousemove", (event) => {
      updateCornerLogoVisibility(event.clientX, event.clientY);
    });

    document.addEventListener("mouseleave", () => {
      cornerLogoLink.classList.remove("visible");
    });

    cornerLogoLink.addEventListener("mouseenter", () => {
      isCornerLogoHovered = true;
      cornerLogoLink.classList.add("visible");
    });

    cornerLogoLink.addEventListener("mouseleave", (event) => {
      isCornerLogoHovered = false;
      updateCornerLogoVisibility(event.clientX, event.clientY);
    });

    window.addEventListener("resize", () => {
      syncLogoOffsetWithStage();
    });

    syncLogoOffsetWithStage();

    void start();
  </script>
</body>
</html>
